=======================
Windowing
=======================

Ovdje smo implementirali Hann prozorsku funkciju

1) Otkud potreba za prozorskom funkcijom?

- U digitalnoj obradi signala analizu radimo po okvirima.
- Na primjer audio signal možemo izdjeliti na frejmove od po 20ms i 
nad takvim frejmovima vršimo sve dalje transformacije i analizu.
- Problem predstavljaju dijelovi gdje se frejmovi spajaju jer tu imamo
diskontinuitet što u spektralnom domenu uvodi šum sa strane svake komponente.
- Prozorske funkcije služe kako bi ovaj side-lobe otklonile i pružile stabilan
spektar.

2) Kako radi Hann prozorska funkcija?

- Hann je prozorska kosinusna funkcija koja spušta rubove signala u spektralnom
domenu ka nuli. 
- Formula:
  w(n) = 0.5 * (1 - cos(2 * π * n / N))

* w(n) vrijednost funkcije u n-tom odbirku,
* n trenutni odbirak
* N ukupan broj odbiraka

3) C++ Implementacija

- Implementirane su sljedeće funkcije:
  hann(int n, int N) i apply_hann_window(std::vector<float>& frame)
- Hann računa vrijednost na nivou odbirka, i napisana je kao inline funkcija
kako bi sugerisali kompajleru da direktno ubaci ovaj dio koda, jer je sama hann
funkcija samo formula i nije nam potreban overhead koji bi standardni poziv 
funkcije imao.
- apply_hann_window radi na nivou frejma za sve odbirke

============================
FFT (Fast Fourier Transform)
============================

1) Zašto koristimo Furijeovu transformaciju?

- MFCC koeficijenti žele da uhvate perceptivno značajne frekvencije nekog zvuka.
- Da bi se ovo ostvarilo sam signal moramo predstavit u frekvencijskom domenu.
- Furijeova transformacija razlaže signal na sinusne i kosinusne komponente, kako bi predstavili
magnitudu (energiju) i fazu svake frekvencije.

2) Koji su nacini implementacije Furijeove transformacije?

- Koriscenje formule kojom je definisana DFT zahtijeva prolazak kroz N odbiraka frejma
za svaki od N odbiraka frejma kako bi izracunali vrijednost što znači da je time complexity O(N^2)
- Kao alternativa ovom pristupu osmisljen je rekurzivni algoritam (Cooley-Tukey) koji dijeli frejm
na parne i neparne odbirke dok velicina frejma ne dosegne 1
- Ovaj algoritam dijeli problem na 2 dijela sto daje log(N) segmenata pružajuci ukupno O(N log N)
time complexity sto ce zbog dalje upotrebe u realnom vremenu značajno ubrzati rad

3) Kako radi Cooley - Tukey?

- Prije svega neophodno je prozorirane odbirke pretvoriti u kompleksne brojeve, jer je Furijeova
transformacija kompleksna transformacija. U te svrhe koristimo funkciju to_complex()
- Dijelimo frejm na parne i neparne indekse i mnozimo sa e^(-2*PI*k)/n koji se naziva twiddle faktor
i mnozimo sa odd kako bi mu okrenuli fazu nakon cega spajamo oba dijela.
- Funkcija vraca rijesenje u obliku kompleksnih brojeva za šta smo koristili std::complex

4) Šta je power spectrum?

- Za dalji rad sa Mel frekvencijskom transformacijom neophodno je da imamo predstavu energije po frekvencijama
- Magnituda svakog frekvencijskog bina pokazuje nam koliko energije ima ta frekvencija
- U funkciji power_spectrum koristimo kvadrat magnitude kako bi izrazili energiju i nakon toga dijelimo sa ukupnim
brojem odbiraka kako bi dobili normalizovane vrijednosti.
- Ovo se vrsi kako bi uskladili vrijednosti za poredjenje nezavisno od dužine frejma nad kojim se ovo vrši.


=====================================================
Mel filterbank (Mel frekvencijska transformacija)
=====================================================

U ovom dijelu projekta implementirali smo Mel filterbank koji se primjenjuje na FFT POWER spektar.

1) Ulaz i izlaz

- Ulaz je POWER spektar realnog signala, samo pozitivne frekvencije:
  power_spectrum[k] = |X[k]|^2,  k = 0..(n_fft/2)
  (znači broj binova je n_fft/2 + 1)

- Povezivanje bina i frekvencije (korisno za intuiciju):
  f_k = k * sample_rate / n_fft
  Δf = sample_rate / n_fft

- Izlaz je vektor Mel energija:
  mel[m], m = 0..n_mels-1

2) Šta Mel filterbank radi i zašto?

- FFT je na linearnoj Hz skali (svaki bin je isti razmak u Hz).
- Ljudsko uho ima bolju rezoluciju na nižim frekvencijama nego na višim.
- Mel filterbank “sabije” spektar u n_mels kanala tako da su kanali gušći na nižim frekvencijama, a rjeđi na višim.

3) Mel skala (Hz <-> Mel)

- Koristimo standardnu (HTK) Mel skalu:
  mel = 2595 * log10(1 + f/700)
  f = 700 * (10^(mel/2595) - 1)

4) Kako gradimo filtere (trouglovi)

- Napravimo n_mels + 2 tačke ravnomjerno na Mel skali između fmin i fmax.
- Te tačke pretvorimo nazad u Hz i mapiramo na FFT bin indekse.
- Svaki filter je trougao definisan sa (left, center, right) binom.
- Težina ide 0 -> 1 (left do center) i 1 -> 0 (center do right).
- Drugim riječima, filter je “najosjetljiviji” na frekvencije oko center bina.
- Ako bin k padne između left i center, doprinos raste linearno, a između center i right opada linearno.
- U kodu koristimo normalizaciju po sumi (normalize_by_sum=true) da skala Mel energija bude stabilnija.

5) Kako računamo Mel energije

- Za svaki mel kanal m radimo ponderisanu sumu:
  mel[m] = Σ_k filterbank[m][k] * power_spectrum[k]

6) C++ implementacija

- build_mel_filterbank(sample_rate, n_fft, n_mels, fmin, fmax, normalize_by_sum)
  vraća matricu težina dimenzija [n_mels][n_fft/2 + 1].

- mel_energies_from_power_spectrum(power_spectrum, filterbank)
  primjenjuje već izgrađeni filterbank.

- mel_energies(power_spectrum, ...)
  “convenience” poziv koji prvo napravi filterbank pa ga primijeni.

- mel_energies_from_frame(frame, ...)
  pomoćna funkcija koja radi: frame -> FFT -> power_spectrum_rfft -> Mel.

Napomena (šta znači “convenience”): to su pomoćne funkcije koje spajaju više koraka u jedan poziv,
da se lakše testira i da je kod kraći. Za real-time se obično koristi već izgrađen filterbank (bez rebuild-a svaki frejm).

Napomena: u mel.cpp postoji komentarisani main() za jednostavan test (1kHz sinus).

7) Šta očekivati na realnom frejmu (intuicija)

- Ako je frejm skoro tišina, većina mel[m] će biti vrlo mala (blizu 0).
- Ako je frejm “čist ton” (npr. 1kHz sinus), energija će se pojaviti u 1-3 susjedna mel kanala.
- Ako je frejm govor ili muzika, energija će biti raspoređena na više kanala, ali i dalje neće biti ravna.

8) Tipični parametri (za studentski projekat)

- sample_rate: 16000 Hz (često za govor)
- n_fft: 512 (oko 32ms na 16kHz) ili 400 (25ms)
- n_mels: 26 ili 40
- fmin: 0 Hz, fmax: sample_rate/2


========================
Log energy (Log-Mel kompresija)
========================

Ovo je korak odmah nakon Mel filterbank-a.
Uzima Mel energije i radi logaritamsku kompresiju po elementu.

1) Ulaz i izlaz

- Ulaz: mel[m] (Mel energije), m = 0..n_mels-1
- Izlaz: logmel[m] = ln(mel[m] + eps)

Koristimo prirodni log (std::log). eps (default 1e-12) je tu da izbjegnemo ln(0).

2) Zašto radimo log?

- Mel energije imaju veliki raspon vrijednosti. Log to “stisne” i daje stabilnije feature-e.
- Ljudsko uho približno logaritamski doživljava jačinu zvuka.
- Još jedna praktična stvar: log pretvara multiplikativne promjene u aditivne, pa je dalje poređenje lakše.

3) Numerika (bitno za implementaciju)

- Mel energije su teorijski >= 0, ali zbog floating-point greške može doći mala negativna vrijednost.
  U kodu se to clamp-uje na 0 prije log-a.
- eps mora biti > 0.

4) C++ implementacija

- log_energy_inplace(std::vector<float>& mel, float eps)
  radi log direktno nad postojećim vektorom (brže, bez dodatne alokacije).

- log_energy(const std::vector<float>& mel, float eps)
  vraća novi vektor.

- log_mel_energies_from_power_spectrum(power, filterbank, eps)
  “spaja” mel + log kad već imaš filterbank.

- log_mel_energies(power, sample_rate, n_fft, n_mels, fmin, fmax, eps)
  sve u jednom (pravi filterbank svaki put, nije idealno za real-time).

Napomena: u log.cpp postoji komentarisani main() sa “fake” power spektrum pikovima.

5) Šta očekivati u log-Mel izlazu

- Ako je mel[m] = 0, onda je logmel[m] ≈ ln(eps). Za eps=1e-12 to je oko -27.63.
- Aktivni mel kanali (gdje ima energije) biće mnogo veći (npr. od -5 do +5, zavisi od signala i normalizacije).
- Log korak se skoro uvijek radi prije DCT jer daje stabilnije koeficijente.

Mala napomena: u ovom projektu koristimo prirodni log (ln). U nekim bibliotekama se može naći i log10,
ali ideja (kompresija) je ista.


========================
DCT (MFCC koeficijenti)
========================

Ovo je zadnji korak u MFCC dijelu: DCT se primjenjuje na log-Mel vrijednosti.

1) Ulaz i izlaz

- Ulaz: logmel[m], m = 0..(n_mels-1)
- Izlaz: DCT koeficijenti c[k], k = 0..(n_mels-1)
- MFCC: u praksi uzimamo samo prvih n_mfcc koeficijenata (npr. 13):
  mfcc[i] = c[i]

2) Šta dobijamo DCT-om (intuicija)

- DCT “prepiše” log-mel vektor u kosinusne komponente.
- Susjedni mel kanali su često slični, pa se informacija sabije u prvih nekoliko koeficijenata.
- `c0` je (skalirani) prosjek log-mel vrijednosti (povezano sa ukupnom energijom u log domenu).
- `c1, c2, ...` opisuju oblik spektralne omotnice (timbre), dok visoki koeficijenti hvataju fine detalje.

3) Formula (DCT-II, ortho)

c[k] = alpha(k) * Σ_{n=0}^{N-1} logmel[n] * cos( (π / N) * (n + 0.5) * k )

alpha(0) = sqrt(1/N)
alpha(k) = sqrt(2/N) za k > 0

Poseban slučaj za k=0 (bitno za tumačenje c0):
c[0] = sqrt(1/N) * Σ_{n=0}^{N-1} logmel[n]
što znači da je c0 (skalirani) prosjek log-mel vrijednosti.

4) C++ implementacija

- dct_ii_ortho(const std::vector<float>& x)
  računa DCT-II (ortho) nad vektorom.

- dct_mfcc(const std::vector<float>& log_mel, int n_mfcc)
  vrati samo prvih n_mfcc koeficijenata.

Napomena: u dct.cpp postoji komentarisani main() koji testira lanac (power -> mel -> log -> dct).

5) Kako tumačiti MFCC koeficijente (kratko)

- c[0] je (skalirani) prosjek log-mel vrijednosti, pa je povezan sa ukupnim nivoom energije u log domenu.
- c[1], c[2], c[3] opisuju “glatki oblik” spektralne omotnice (timbre) i obično nose najviše korisne informacije.
- Viši koeficijenti hvataju fine detalje koji su često osjetljiviji na šum.

6) Zašto uzimamo samo prvih 12/13 koeficijenata?

- U praksi je informacija uglavnom koncentrisana u nižim indeksima.
- Manji broj koeficijenata = manji ulaz za model i stabilniji feature-i.

Kratak pregled pipeline-a (od frejma do MFCC):
frame -> Hann -> FFT -> power_spectrum_rfft -> Mel -> log -> DCT -> MFCC