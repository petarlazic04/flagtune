=======================
Windowing
=======================

Ovdje smo implementirali Hann prozorsku funkciju

1) Otkud potreba za prozorskom funkcijom?

- U digitalnoj obradi signala analizu radimo po okvirima.
- Na primjer audio signal možemo izdjeliti na frejmove od po 20ms i 
nad takvim frejmovima vršimo sve dalje transformacije i analizu.
- Problem predstavljaju dijelovi gdje se frejmovi spajaju jer tu imamo
diskontinuitet što u spektralnom domenu uvodi šum sa strane svake komponente.
- Prozorske funkcije služe kako bi ovaj side-lobe otklonile i pružile stabilan
spektar.

2) Kako radi Hann prozorska funkcija?

- Hann je prozorska kosinusna funkcija koja spušta rubove signala u spektralnom
domenu ka nuli. 
- Formula:
  w(n) = 0.5 * (1 - cos(2 * π * n / N))

* w(n) vrijednost funkcije u n-tom odbirku,
* n trenutni odbirak
* N ukupan broj odbiraka

3) C++ Implementacija

- Implementirane su sljedeće funkcije:
  hann(int n, int N) i apply_hann_window(std::vector<float>& frame)
- Hann računa vrijednost na nivou odbirka, i napisana je kao inline funkcija
kako bi sugerisali kompajleru da direktno ubaci ovaj dio koda, jer je sama hann
funkcija samo formula i nije nam potreban overhead koji bi standardni poziv 
funkcije imao.
- apply_hann_window radi na nivou frejma za sve odbirke

============================
FFT (Fast Fourier Transform)
============================

1) Zašto koristimo Furijeovu transformaciju?

- MFCC koeficijenti žele da uhvate perceptivno značajne frekvencije nekog zvuka.
- Da bi se ovo ostvarilo sam signal moramo predstavit u frekvencijskom domenu.
- Furijeova transformacija razlaže signal na sinusne i kosinusne komponente, kako bi predstavili
magnitudu (energiju) i fazu svake frekvencije.

2) Koji su nacini implementacije Furijeove transformacije?

- Koriscenje formule kojom je definisana DFT zahtijeva prolazak kroz N odbiraka frejma
za svaki od N odbiraka frejma kako bi izracunali vrijednost što znači da je time complexity O(N^2)
- Kao alternativa ovom pristupu osmisljen je rekurzivni algoritam (Cooley-Tukey) koji dijeli frejm
na parne i neparne odbirke dok velicina frejma ne dosegne 1
- Ovaj algoritam dijeli problem na 2 dijela sto daje log(N) segmenata pružajuci ukupno O(N log N)
time complexity sto ce zbog dalje upotrebe u realnom vremenu značajno ubrzati rad

3) Kako radi Cooley - Tukey?

- Prije svega neophodno je prozorirane odbirke pretvoriti u kompleksne brojeve, jer je Furijeova
transformacija kompleksna transformacija. U te svrhe koristimo funkciju to_complex()
- Dijelimo frejm na parne i neparne indekse i mnozimo sa e^(-2*PI*k)/n koji se naziva twiddle faktor
i mnozimo sa odd kako bi mu okrenuli fazu nakon cega spajamo oba dijela.
- Funkcija vraca rijesenje u obliku kompleksnih brojeva za šta smo koristili std::complex

4) Šta je power spectrum?

- Za dalji rad sa Mel frekvencijskom transformacijom neophodno je da imamo predstavu energije po frekvencijama
- Magnituda svakog frekvencijskog bina pokazuje nam koliko energije ima ta frekvencija
- U funkciji power_spectrum koristimo kvadrat magnitude kako bi izrazili energiju i nakon toga dijelimo sa ukupnim
brojem odbiraka kako bi dobili normalizovane vrijednosti.
- Ovo se vrsi kako bi uskladili vrijednosti za poredjenje nezavisno od dužine frejma nad kojim se ovo vrši.


=====================================================
Mel filterbank (Mel frekvencijska transformacija)
=====================================================

U ovom dijelu projekta implementirali smo Mel filterbank koji se primjenjuje na FFT spektar.

1) Šta je ulaz i šta je “spectrum bin”?
- Nakon FFT dužine N (= n_fft), dobijamo diskretan spektar po frekvencijskim "binovima".
- Bin je indeks k u FFT rezultatu. Za realan signal najčešće koristimo samo pozitivne frekvencije: 
broj binova = n_fft/2 + 1.
- Frekvencija centra bina: 
f_k = k * sample_rate / n_fft
- Razmak između binova (frekvencijska rezolucija): 
Δf = sample_rate / n_fft

U implementaciji ne računamo FFT, već pretpostavljamo da već imamo spektar u obliku:
- power_spectrum[k] = |X[k]|^2  (POWER spektar)
Napomena: to nije magnituda |X[k]|, nego kvadrat magnitude (energija po binu).

2) Šta radi Mel filterbank (realna interpretacija)?
Cilj Mel filterbank-a je da “sabije” linearni FFT spektar u manji broj kanala koji bolje odgovaraju ljudskoj percepciji frekvencije:
- Na niskim frekvencijama imamo finiju rezoluciju (više “kanala” po Hz),
- Na višim frekvencijama rezolucija je grublja.

Rezultat je vektor Mel energija:
mel[m], m = 0..n_mels-1
Svaki mel[m] predstavlja energiju signala u jednom perceptualnom frekvencijskom opsegu (Mel band).

3) Mel skala (mapiranje Hz <-> Mel)
Koristimo standardnu (HTK) Mel skalu:
- mel = 2595 * log10(1 + f/700)
- f = 700 * (10^(mel/2595) - 1)

4) Kako se grade filteri (trougaoni filterbank)
Za n_mels filtera, prvo napravimo n_mels + 2 Mel tačke ravnomjerno raspoređene na Mel skali između fmin i fmax.
Te tačke zatim:
- pretvaramo iz Mel u Hz,
- mapiramo na FFT binove (diskretna mreža):
  bin = floor((n_fft + 1) * hz / sample_rate)
Svaki Mel filter je trougao definisan sa 3 indeksa:
- left  = bin_points[m]
- center= bin_points[m+1]
- right = bin_points[m+2]
Težine rastu od left do center (0 -> 1) i padaju od center do right (1 -> 0).

Opcionalno radimo normalizaciju:
- normalize_by_sum = true
- svaki filter se normalizuje tako da zbir njegovih težina bude 1
Ovo stabilizuje skalu izlaznih Mel energija (da ne zavisi previše od broja binova koje filter pokriva).

5) Kako se filterbank primjenjuje na spektar (dobijanje Mel energija)
Mel energija se računa kao ponderisana suma (suma sa težinama) power spektra:
mel[m] = Σ_k filterbank[m][k] * power_spectrum[k]

To znači:
- ako u nekom FFT binu imamo pik energije, on će doprinijeti jednom ili dva susjedna Mel kanala (u zavisnosti od toga gdje bin pada u trouglu).

6) Implementacija (C++)
Implementirane su sljedeće funkcije:
- build_mel_filterbank(...)
  Pravi matricu težina dimenzija [n_mels][n_fft/2 + 1].
- mel_energies_from_power_spectrum(power_spectrum, filterbank)
  Primjenjuje filterbank na POWER spektar i vraća Mel energije.
- mel_energies(...)
  Convenience funkcija: build + apply u jednom pozivu.

U mel.cpp postoji i main() koji služi kao demo/test:
- ručno se postavi nekoliko nenultih vrijednosti u power spektru (simulacija pikova),
- ispišu se nenulti binovi (k, f_k, power),
- ispiše se dio filterbank težina (preview),
- ispišu se dobijene Mel energije.


========================
Log energy (Log-Mel kompresija)
========================

U ovom dijelu projekta implementirali smo “log” korak koji dolazi odmah nakon Mel filterbank-a.
Ovaj korak uzima vektor Mel energija i radi logaritamsku kompresiju po elementu.

1) Šta je ulaz i izlaz?

- Ulaz: vektor Mel energija (izlaz iz mel.cpp)
  mel[m], m = 0..n_mels-1
  gdje je mel[m] = Σ_k filterbank[m][k] * power_spectrum[k]

- Izlaz: log-Mel energije (log kompresovane mel energije)
  logmel[m] = log(mel[m] + eps)

Napomena:
- Koristimo prirodni logaritam (ln), tj. std::log.
- eps je mala pozitivna konstanta (default 1e-12) koja sprječava log(0).


2) Zašto radimo log kompresiju?

- Kompresija dinamičkog opsega:
  Mel energije mogu imati veliki raspon (od skoro 0 do velikih vrijednosti), a log ih “stisne”
  i daje stabilnije feature-e.

- Perceptualni razlog:
  Ljudska percepcija jačine zvuka je približno logaritamska, pa log-Mel bolje prati sluh.

- Stabilnost za dalje korake (npr. DCT/MFCC):
  Log pretvara multiplikativne promjene u aditivne, pa je dalje procesiranje često robusnije.


3) Numeričke napomene (eps i clamp)

- Teorijski, Mel energije su ≥ 0 (jer dolaze iz power spektra i nenegativnih težina).
- U praksi, zbog floating-point šuma može se pojaviti jako mala negativna vrijednost.
  U implementaciji se takve vrijednosti clamp-uju na 0 prije log-a.
- eps mora biti > 0.


4) “Mel izlaz je log ulaz” (povezivanje modula)

- U praksi pipeline izgleda ovako:
  power_spectrum  ->  mel_energies_from_power_spectrum(...)  ->  log_energy_inplace(...)

- Ako već imsmo pre-built filterbank (real-time slučaj), preporučeni poziv je:
  log_mel_energies_from_power_spectrum(power_spectrum, filterbank, eps)

- Ako želimo sve u jednom (nije idealno za real-time jer pravi filterbank svaki put):
  log_mel_energies(power_spectrum, sample_rate, n_fft, n_mels, fmin, fmax, eps)


5) Implementacija (C++)

Implementirane su sljedeće funkcije u log.hpp/log.cpp:

- log_energy_inplace(std::vector<float>& mel_energies, float eps)
  Radi log kompresiju direktno nad postojećim vektorom (bez dodatne alokacije).

- log_energy(const std::vector<float>& mel_energies, float eps)
  Out-of-place verzija (vraća novi vektor).

- log_mel_energies_from_power_spectrum(power_spectrum, filterbank, eps)
  Direktna veza između mel.cpp i log.cpp: mel izlaz → log ulaz.

- log_mel_energies(power_spectrum, sample_rate, n_fft, n_mels, fmin, fmax, eps)
  Convenience funkcija: build + apply + log.


6) Demo/test u log.cpp

U log.cpp postoji demo main() (komentarisan u bloku /* ... */) koji:
- napravi “fake” power spektar sa nekoliko pikova,
- izgradi Mel filterbank,
- izračuna Mel energije,
- izračuna log-Mel vrijednosti i ispiše ih.


========================
DCT (MFCC koeficijenti)
========================

U ovom dijelu projekta implementirali smo DCT (Discrete Cosine Transform) koji se primjenjuje na log-Mel energije.
Ovo je završni korak za dobijanje MFCC koeficijenata.

1) Šta je ulaz i izlaz?

- Ulaz: log-Mel energije (izlaz iz log.cpp)
  logmel[n], n = 0..N_mels-1

- Izlaz (DCT): vektor DCT koeficijenata iste dužine (N_mels)
  c[k], k = 0..N_mels-1

- Izlaz (MFCC): u praksi ne koristimo sve koeficijente, nego uzimamo prvih N_mfcc:
  mfcc[i] = c[i], i = 0..N_mfcc-1


2) Zašto koristimo DCT na log-Mel vrijednostima?

- DCT radi “de-korelaciju” komponenti:
  Log-Mel vektor ima susjedne kanale koji su često slični (korelirani). DCT prebacuje taj opis u kosinusnu bazu,
  gdje je energija često koncentrisana u manjem broju koeficijenata.

- Kompresija informacije:
  Umjesto da čuvamo N_mels vrijednosti, dovoljno je zadržati prvih N_mfcc koeficijenata (npr. 12 ili 13),
  koji opisuju glatki “oblik” spektralne omotnice.

- Fizičko značenje (intuicija):
  DCT koeficijenti opisuju oblik log-Mel spektra.
  Niski indeksi (c0, c1, c2...) opisuju spore/glatke promjene kroz frekvenciju (timbre / forma spektra),
  a visoki indeksi opisuju fine “nazubljene” detalje (koji su često manje stabilni).


3) Korištena formula (DCT-II, ortho)

Koristimo standardnu DCT-II transformaciju sa ortonormalnom normalizacijom ("ortho"):

c[k] = alpha(k) * Σ_{n=0}^{N-1} logmel[n] * cos( (π / N) * (n + 0.5) * k )

gdje je:
- alpha(0) = sqrt(1/N)
- alpha(k) = sqrt(2/N) za k > 0


4) Implementacija (C++)

Implementirane su sljedeće funkcije u dct.hpp/dct.cpp:

- dct_ii_ortho(const std::vector<float>& x)
  Računa kompletan DCT-II (ortho) nad ulaznim vektorom x (tipično: log-Mel).
  Vraća vektor iste dužine kao ulaz.

- dct_mfcc(const std::vector<float>& log_mel, int n_mfcc)
  Convenience funkcija za MFCC:
  1) izračuna dct_ii_ortho(log_mel)
  2) vrati samo prvih n_mfcc koeficijenata.


5) Demo/test u dct.cpp

U dct.cpp postoji demo main() koji testira pipeline:
power_spectrum -> Mel -> log-Mel -> DCT -> MFCC
i ispisuje log-Mel vrijednosti i MFCC koeficijente.